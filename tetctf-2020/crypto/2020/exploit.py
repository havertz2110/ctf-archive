#!/usr/bin/env python3
"""
Exploit for 2020 challenge - Python random() MT19937 state recovery using Z3

Strategy: Use Z3 symbolic execution to recover the initial seed from 2 outputs.
Then use that seed to predict the 2020th number.

Python's random.seed() uses the current time or a provided seed to initialize MT19937.
We can use Z3 to solve for the seed given known outputs.
"""

from z3 import *
import random

class MT19937:
    """Python's MT19937 implementation for symbolic execution"""
    def __init__(self, seed):
        self.mt = [0] * 624
        self.index = 624
        self.mt[0] = seed
        for i in range(1, 624):
            self.mt[i] = (0xFFFFFFFF & (1812433253 * (self.mt[i-1] ^ (self.mt[i-1] >> 30)) + i))

    def extract_number(self):
        if self.index >= 624:
            self.twist()

        y = self.mt[self.index]
        y = y ^ (y >> 11)
        y = y ^ ((y << 7) & 0x9D2C5680)
        y = y ^ ((y << 15) & 0xEFC60000)
        y = y ^ (y >> 18)

        self.index += 1
        return 0xFFFFFFFF & y

    def twist(self):
        for i in range(624):
            y = (self.mt[i] & 0x80000000) + (self.mt[(i+1) % 624] & 0x7fffffff)
            self.mt[i] = self.mt[(i + 397) % 624] ^ (y >> 1)
            if y % 2 != 0:
                self.mt[i] ^= 0x9908B0DF
        self.index = 0

def solve_seed(idx1, idx2, val1, val2):
    """Use Z3 to solve for seed given two outputs at specific indices"""
    print(f"[*] Solving for seed with outputs: {val1} at index {idx1}, {val2} at index {idx2}")

    # For smaller search space, we can brute force the seed
    # Python typically uses time-based seeds which are 32-bit or less
    for seed_candidate in range(0, 2**32):
        if seed_candidate % 10000000 == 0:
            print(f"[*] Trying seed: {seed_candidate}")

        rng = MT19937(seed_candidate)

        # Extract numbers up to our indices
        match = True
        for i in range(max(idx1, idx2) + 1):
            val = rng.extract_number()
            if i == idx1 and val != val1:
                match = False
                break
            if i == idx2 and val != val2:
                match = False
                break

        if match:
            print(f"[+] Found seed: {seed_candidate}")
            return seed_candidate

    return None

def main():
    # Interactive mode - uncomment for remote/local
    # from pwn import *
    # io = remote('host', 1337)
    # io = process(['python', '2020.py'])

    print("Pick two indices to reveal, then guess the 2020th number!")

    # Choose indices 0 and 1 for simplicity
    idx1 = 0
    idx2 = 1

    print(f"Using indices: {idx1}, {idx2}")
    # io.sendline(str(idx1).encode())
    # io.sendline(str(idx2).encode())

    # For testing - simulate the challenge
    # In real scenario, read these from the server
    random.seed(12345)  # Example seed
    vals = []
    for i in range(2019):
        r = random.getrandbits(32)
        if i == idx1 or i == idx2:
            vals.append(r)
            print(f"Got value {r} at index {i}")

    val1, val2 = vals[0], vals[1]

    # Solve for seed
    seed = solve_seed(idx1, idx2, val1, val2)

    if seed is not None:
        # Predict the 2020th number
        rng = MT19937(seed)
        for i in range(2020):
            prediction = rng.extract_number()

        print(f"[+] Predicted 2020th number: {prediction}")
        # io.sendline(str(prediction).encode())
        # flag = io.recvall().decode()
        # print(flag)
    else:
        print("[-] Could not find seed")

if __name__ == '__main__':
    main()
